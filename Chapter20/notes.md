# Контрольные вопросы

#### 1. Почему программы, написанные разными людьми, выглядят по-разному? Приведите примеры. (Люди могут использовать различный кодстайл (например, snake_case и CamelCase), программы могут быть написаны на разных языках программирования (Джек пишет на C, а Джилл на C++) и т.д.)
 
#### 2. Какие простые вопросы мы обычно задаем, думая о памяти? (Как корректно выделить для тех или иных целей память и впоследствии очистить её, чтобы избежать утечки? Как корректно написать конструктор и деструктор? Сколько места занимает определённый мною тип данных?)

#### 3. Перечислите разные способы хранения данных. (Переменная, контейнер, файл, база данных и др.)

#### 4. Какие основные операции можно выполнить с коллекцией данных? (Добавлять, удалять, получать, сортировать и т.д.)

#### 5. Каких принципов следует придерживаться при хранении данных? (Единообразный доступ к данным: не зависящий от способа хранения данных и не зависящий от типа даннных; доступ к данным, безопасный с точки зрения типа; легкий обход данных; компактное хранение данных; скорость выполнения: поиска данных, добавления данных и удаления данных; стандартные версии большинства широко распостраненных алгоритмов таких, как copy, find, search, sort, sum, ... .)

#### 6. Что такое последовательность STL? (С точки зрения STL любая коллекция данных представляет собой последовательность. Последовательность имеет начало и конец. Мы можем перемещаться по последовательности от начала к концу, при необходимости считывая или записывая значение элементов. Начало и конец последовательности идентифицируются парой итераторов.)

#### 7. Что такое итератор STL? Какие операции поддерживают итераторы? (Итератор - это объект, идентифицирующий элемент последовательности. Основные операции над стандартными итераторами: ==, !=, *, =, ++.)

#### 8. Как переместить итератор на следующий элемент? (Использовать операцию ++.)

#### 9. Как переместить итератор на предыдущий элемент? (Использовать операцию --.)

#### 10. Что произойдет, если вы попытаетесь переместить итератор за конец последовательности? (Мы попадём в неинициализированную ячейку памяти, что может привести к неверному ответу, либо же получим ошибку.)

#### 11. Какие виды итераторов могут перемещаться к предыдущему элементу? (Двунаправленный итератор и итератор с произвольным доступом.)

#### 12. Почему полезно отделять данные от алгоритмов? (Автор кода знает о существовании итераторов (но не знает, как именно они обращаются к данным), а поставщик данных предоставляет итераторы, не раскрывая пользователям детали механизма хранения данных. В результате получаем достаточно независимые друг от друга алгоритмы и контейнеры. Процитируем Алекса Степанова: "Алгоритмы и контейнеры STL потому так хорошо и работают друг с другом, что ничего не знают друг о друге".)

#### 13. Что такое STL? (Стандартная библиотека языка C++, обеспечивающая основу для работы с данными, представленными в виде последовательности элементов. Расшифровывается как "стандартная библиотека шаблонов" ("standart template library").)

#### 14. Что такое связанный список? Чем он фундаментально отличается от вектора? (Если отвечать на этот вопрос в рамках данной главы, то связанный список - это структура данных, которая точнее всего соответствует диаграмме последовательности в STL. Одно из основных различий вектора и списка заключается в том, что мы можем вставить в любое место списка новый элемент (или удалить существующий) без перемещения остальных элементов, что пришлось бы сделать при использовании вектора.)

#### 15. Что такое узел (в связанном списке)? (Это структура данных, которая хранит в себе элемент и один или несколько указателей.)

#### 16. Что делает функция insert()? Что делает функция erase()? (insert() вставляет элемент в последовательность, erase() удаляет элемент из последовательности.)

#### 17. Как определить, что последовательность пуста? (Последовательность пуста, если v.begin() == v.end().)

#### 18. Какие операции предусмотрены в итераторе класса list? (В итераторе класса list предусмотрены операции *, ++, --, == и !=.)

#### 19. Как обеспечить обход контейнера, используя STL? (Можно использовать итераторы или цикл for с диапазоном.)

#### 20. В каких ситуациях лучше использовать класс string, а не vector? (В тех случаях, когда нам нужны специфичные строковые операции, такие как конкатенация или чтение слов, разделенных пробельными символами.)

#### 21. В каких ситуациях лучше использовать класс list, а не vector? (В тех случаях, когда у нас есть либо очень большая коллекция данных, либо коллекция данных, состоящая из элементов, которые занимают много памяти. Если нам необходимо будет вставить или удалить элемент из какой-то части последовательности, то, используя класс list, мы сможем сделать это без проблем, что может оказаться неэффективным при использовании класса vector.)

#### 22. Что такое контейнер? (Это структура данных, которая организует и хранит коллекцию элементов.)

#### 23. Что должны делать функции begin() и end() в контейнере? (begin() возвращает итератор на первый элемент контейнера, end() возвращает итератор, указывающий на позицию за последним элементом контейнера.)

#### 24. Какие контейнеры предоставляет библиотека STL? (vector, list, deque, map, multimap, unordered_map, unordered_multimap, set, multiset, unordered_set, unordered_multiset, array.)

#### 25. Что такое категория итератора? Какие категории итераторов предлагает библиотека STL? (Категория итератора - это его разновидность, которая обладает определёнными операциями. Библиотека STL предлагает следующие категории итераторов: входной итератор (итератор ввода), выходной итератор (итератор вывода), однонаправленный итератор, двунаправленный итератор, итератор с произвольным доступом.)

#### 26. Какие операции предусмотрены в итераторе с произвольным доступом, но не поддерживаются двунаправленным итератором? (Можно индексировать итератор с произвольным доступом, а также добавлять к нему или вычитать из него целое число.)
