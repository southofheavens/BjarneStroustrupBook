/*
    Рассмотрим ещё один способ определения функции, вычисляющей факториал.
    int fac(int n) { return n > 1 ? n*fac(n-1) : 1; } // n!
    При вычислении, например, fac(4), эта функция сначала выясняет, что, поскольку, 4 > 1, ответ равен
    4*fac(3), что, очевидно, равно 4*3*fac(2) или, рассуждая аналогично, 4*3*2*fac(1), т.е. 4*3*2*1.
    Попытайтесь понять, как работает эта функция. Функция, вызывающая саму себя, называется рекурсивной
    (recursive). Альтернативная реализация, описанная в разделе 15.5, называется итеративная (iterative),
    потому что в ней используется итерация по значениям (в цикле while). Убедитесь, что рекурсивная 
    функция fac() работает и выдает те же результаты, что и итеративная функция fac() при вычислении
    факториала чисел 0, 1, 2, 3, 4 и так далее до 20. Какую реализацию функции fac() вы предпочитаете
    и почему?

    Я бы предпочел реализацию функции fac(), использующую рекурсию, потому что она выглядит проще и,
    если так можно сказать, элегантнее, но для слишком больших значений n рекурсивные вызовы могут
    создавать большой расход ресурсов и привести к переполнению стека, что может привести к ошибкам
    выполнения программы.
*/