# Контрольные вопросы

#### 1. Приведите примеры полезных алгоритмов из библиотеки STL. (find, find_if, count, count_if, sort, copy, unique_copy, merge, equal_range, equal, accumulate, inner_product и другие.)

#### 2. Что делает алгоритм find()? Приведите по крайней мере пять примеров. (r=find(b,e,v) - итератор r указывает на первое вхождение элемента v в последовательность [b,e). r == e означает, что элемент не найден. Примеры: поиск элемента в std::vector, в std::array, в std::string, в std::list, поиск по предикату в std::vector (алгоритм find_if()).)

#### 3. Что делает алгоритм count_if? (x=count_if(b,e,v), где x - количество элементов в последовательности [b,e), таких, что предикат p(x) имеет значение true.) 

#### 4. Что алгоритм sort(b,e) использует в качестве критерия поиска? (Алгоритм sort(b,e) упорядочивает последовательность [b,e) с помощью оператора <.)

#### 5. Как алгоритмы STL получают контейнеры в качестве аргумента ввода? (С помощью итераторов begin() и end(), ссылающихся на первый и следующий за последним элементы входной последовательности.)

#### 6. Как алгоритмы STL получают контейнеры в качестве аргумента вывода? (С помощью итератора begin(), ссылающегося на первый элемент выходной последовательности.)

#### 7. Как алгоритмы STL обозначают ситуации "не найден" или "сбой"? (Если результат работы алгоритма равен end(). Пример: l = find(v.begin(),v.end(),25). Если l == v.end(), значит число 25 в последовательности не найдено.)

#### 8. Что такое функциональный объект? (Объект, который ведет себя как функция. Функциональные объекты необходимы, например, для передачи в качестве аргумента функций, принимающих предикат.)

#### 9. Чем функциональный объект отличается от функции? (Функциональный объект может хранить в себе данные.)

#### 10. Что такое предикат? (Предикат - это функция, возвращающая булевое значение true или false.)

#### 11. Что делает алгоритм accumulate()? (x=accumulate(b,e,i) суммирует последовательности; например, для последовательности {a,b,c,d} результат равен i+a+b+c+d. Тип результата x совпадает с типом начального значения i.)

#### 12. Что делает алгоритм inner_product()? (x=inner_product(b,e,b2,i) перемножает пары значений из двух последовательностей и суммирует результаты; например, для последовательностей {a,b,c,d} и {e,f,g,h} результат равен i + a * e + b * f + c * g + d * h. Тип результата x совпадает с типом начального значения i.)

#### 13. Что такое ассоциативный контейнер? Приведите не менее трех примеров. (Структуры данных, подобные контейнерам map и unordered_map, известны под разными названиями, например ассоциативные массивы, хеш-таблицы и красно-черные деревья. Популярные и полезные концепции всегда имеют много названий. Мы будем называть их ассоциативными контейнерами.)

#### 14. Почему класс list не является ассоциативным контейнером? (Потому, что std::list хранит последовательность элементов, а не уникальных ключей. А также элементы в std::list хранятся в порядке вставки.)

#### 15. Сформулируйте принцип организации бинарного дерева. (Дерево состоит из узлов. В узле хранятс ключ, соответствующее ему значение и указатели на два узла-наследника (левый и правый дети). Ключ левого дочернего узла меньше ключа родителя, ключ правого дочернего узла больше ключа родителя.)

#### 16. Что собой представляет сбалансированное дерево? (Дерево называется сбалансированным, если все одинаково удаленные от корня поддеревья содержат примерно одинаковое количество узлов. В сбалансированном дереве среднее количество узлов, которые мы должны пройти, пока не достигнем заданного узла, минимально. Примеры сбалансированных деревьев поиска - красно-черное дерево и AVL-дерево.)

#### 17. Сколько места занимает элемент в контейнере map? (sizeof(key) + sizeof(value).)

#### 18. Сколько места занимает элемент в контейнере vector? (sizeof(elem).)

#### 19. Зачем нужен контейнер unordered_map, если есть (упорядоченный) контейнер map? (Нужно использовать контейнер unordered_map, если нам необходимо часто выполнять поиск в большом ассоциативном массиве и не нужен упорядоченный обход.)

#### 20. Чем контейнер set отличается от контейнера map? (Контейнер set хранит только уникальные ключи, в то время как контейнер map хранит уникальные ключи и соответствующие им значения.)

#### 21. Чем контейнер multimap отличается от контейнера map? (В контейнере multimap один и тот же ключ может встречаться несколько раз.)

#### 22. Зачем нужен алгоритм copy(), если мы вполне могли бы написать простой цикл? (Алгоритм copy(), как и остальные алгоритмы из библиотеки STL, нужен для того, чтобы упростить жизнь программистам и они могли не переписывать тот код, который уже был когда-то кем-то написан.)

#### 23. Что такое бинарный поиск? (Бинарный поиск - это алгоритм, который выполняет поиск элемента в отсортированном контейнере за O(log_2(N)).)