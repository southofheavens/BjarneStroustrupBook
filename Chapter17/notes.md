# Контрольные вопросы

#### 1. Зачем нужны структуры данных с переменным количеством элементов? (Это удобно и может быть необходимо в некоторых ситуациях. Допустим, что у нас есть контейнер с номерами телефонов сотрудников компании, и один из них решил уволиться. В таком случае мы можем просто удалить его номер телефона, не создавая при этом новый контейнер.)

#### 2. Назовите четыре вида памяти, используемой при работе типичной программы. (Сегмент кода(для кода), сегмент данных(для глобальных переменных), стек(для хранения аргументов функций и локальных переменных) и динамическая(для других целей).)

#### 3. Что такое динамическая память? Как еще ее называют? Какие операторы поддерживают работу с ней? (Это область памяти, не занятая операционной системой или другими загруженными в данный момент программами, не включая сегмент кода, сегмент данных и стек. Динамическую память также называют кучей и free store. Работу с ней поддерживают операторы * и [].)

#### 4. Что такое оператор разыменования и зачем он нужен? (Оператор разыменования позволяет читать и записывать объект, на который указывает указатель. Пример использования оператора разыменования: *p = 8.9;.)

#### 5. Что такое адрес? Как язык C++ работает с адресами? (Адресом называют некоторое число, идентифицирующее ячейку памяти. Для определения адреса объекта используется оператор получения адреса, унарный &. Пример:  
```
int var = 17;
int* ptr = &var; // Указатель ptr хранит адрес переменной var)
```

#### 6. Какую информацию об объекте несет указатель, который на него указывает? Какую полезную информацию он не содержит? (Указатель хранит в себе адрес ячейки, в котором находится объект, а также у указателя есть свой тип (Если некий объект имеет тип X, то указатель, возвращаемый оператором new, имеет тип X*). Основная проблема, связанная с указателями, заключается в том, что указатель не знает, на какое количество элементов он указывает.)

#### 7. На что может указывать указатель? (Указатель указывает на объект определенного типа. Указатели на объекты разных типов имеют разные типы.)

#### 8. Что такое утечка памяти? (Утечкой памяти называется "потеря" памяти, выделенной с помощью оператора new.)

#### 9. Что такое ресурс? (Ресурс - это то, что мы "где-то взяли" и должны вернуть, когда закончим его использовать (динамическая память, файлы, блокировки, дескрипторы потоков, сокеты).)

#### 10. Как можно инициализировать указатель? (Указатель можно инициализировать адресом ячейки либо нулевым указателем (nullptr).)

#### 11. Что такое нулевой указатель? Зачем он нужен? (Если в нашем распоряжении нет другого указателя, которым можно было бы инициализировать наш указатель, то нужно использовать нулевой указатель nullptr. Его следует использовать тогда, когда некоторый указатель временами указывает на какой-то объект, а временами нет.)

#### 12. Когда нужен указатель (а не ссылка или именованный объект)? (Указатель нужно использовать в качестве аргумента функции и делать это в случаях, допускающих в качестве своего аргумента "отсутствующий объект" и не забывать о проверке nullptr!)

#### 13. Что такое деструктор? Когда он нужен? (Деструктор - это функция, противоположная конструктору. Деструктор неявно вызывается, когда объект выходит за пределы области видимости и гарантирует, что объект будет правильно очищен перед тем, как будет уничтожен.)

#### 14. Зачем нужен виртуальный деструктор? (Виртуальный деструктор (~Shape()) базового класса с помощью механизма вызова виртуальной функции вызывает деструктор (~Text()) производного класса. Если бы деструктор базового класса (Shape::~Shape()) не был виртуальным, то деструктор производного класса (Text::~Text()) не был бы вызван и член производного класса (Text) не был бы корректно уничтожен. Пример:
```
Shape* fct()
{
    Text tt{Point{200,200},"Annemarie"};
    // ...
    Shape* p = new Text{Point{100,100},"Nicholas"};
    return p;
}

void f()
{
    Shape* = fct();
    // ...
    delete q;
} )
```

#### 15. Как вызываются деструкторы членов класса? (При удалении объекта некоторого класса, сначала вызывается деструктор самого объекта, а этот деструктор, в свою очередь, вызывает деструкторы членов класса (если таковые имеются).)

#### 16. Что такое приведение типов? Когда оно необходимо? (Приведением называют такие операторы, как static_cast, reinterpret_cast и const_cast. static_cast позволяет явно преобразовать указатели связанных типов один в другой, например такие, как void* или double*. Пример:
```
void f(void* pv)
{
    double* pd = pv; // Ошибка: невозможно привести тип void* к double*
    int* pi = static_cast<int*>(pv); // OK: явное преобразование
    // ...
} )
```

#### 17. Как получить доступ к члену класса с помощью указателя? (С помощью оператора ->.)

#### 18. Что такое двусвязный список? (Двусвязным списком называют список, в котором для данного узла мы можем определить предшествующий и последующий узлы.)

#### 19. Что собой представляет ключевое слово this и когда оно используется? (Ключевое слово this представляет из себя указатель на данный объект. Оно используется для получения указателя на объект, для которого была вызвана функция данного класса.)
